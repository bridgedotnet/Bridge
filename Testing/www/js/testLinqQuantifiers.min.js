"use strict";Bridge.define("ClientTestLibrary.Linq.TestLinqQuantifiers",{statics:{test:function(n){var t,i,r,u,f,e,o,s;n.expect(4);t=["count","tree","mount","five","doubt"];i=Bridge.Linq.Enumerable.from(t).any(function(n){return Bridge.String.contains(n,"ou")});n.ok(i,"Any() to return words containing 'ou'");r=[3,7,9,5,247,1000001];u=Bridge.Linq.Enumerable.from(r).all(function(n){return n%2==1});n.ok(u,"All() is odd");f=[2,3,7,9,5,247,1000001];e=!Bridge.Linq.Enumerable.from(f).all(function(n){return n%2==1});n.ok(e,"All() is not only odd");o=Bridge.Linq.Enumerable.from(ClientTestLibrary.Utilities.Person.getPersons()).groupBy(function(n){return n.getGroup()}).where(function(n){return n.any(function(n){return n.getCount()>=500})}).select(function(n){return{group:n.key(),names:n.select(function(n){return n.getName()}).toArray()}}).toArray();s=[{group:"C",names:["Zeppa","Billy"]},{group:"B",names:["John","Dora","Ian","Mary"]},{group:Bridge.cast(null,String),names:["Nemo"]}];n.deepEqual(o,s,"Any() to return a grouped array of names only for groups having any item with Count > 500")}}});Bridge.init();